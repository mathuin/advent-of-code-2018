// opcodes.js

const fs = require('fs');

// opcode map
exports.opMap = new Map([
  [
    // addr: add register (stores in register C sum of reg A and B)
    "addr",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = reg[a] + reg[b];
      return reg;
    }
  ],
  [
    // addi: add immediate (stores in register C sum of register A and value B)
    "addi",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = reg[a] + b;
      return reg;
    }
  ],
  [
    // mulr: multiply register (stores in register C product of reg A and B)
    "mulr",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = reg[a] * reg[b];
      return reg;
    }
  ],
  [
    // muli: multiply immediate (stores in register C product of register A and value B)
    "muli",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = reg[a] * b;
      return reg;
    }
  ],
  [
    // banr: bitwise AND register
    "banr",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = reg[a] & reg[b];
      return reg;
    }

  ],
  [
    // bani: bitwise AND immediate
    "bani",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = reg[a] & b;
      return reg;
    }
  ],
  [
    // borr: bitwise OR register
    "borr",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = reg[a] | reg[b];
      return reg;
    }
  ],
  [
    // bori: bitwise OR immediate
    "bori",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = reg[a] | b;
      return reg;
    }
  ],
  [
    // setr: set register
    "setr",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = reg[a];
      return reg;
    }
  ],
  [
    // seti: set immediate
    "seti",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = a;
      return reg;
    }
  ],
  [
    // gtir: greater-than immediate/register
    "gtir",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = (a>reg[b]) ? 1 : 0;
      return reg;
    }
  ],
  [
    // gtri: greater-than register/immediate
    "gtri",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = (reg[a]>b) ? 1 : 0;
      return reg;
    }
  ],
  [
    // gtrr: greater-than register/register
    "gtrr",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = (reg[a]>reg[b]) ? 1 : 0;
      return reg;
    }
  ],
  [
    // eqir: equal immediate/register
    "eqir",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = (a===reg[b]) ? 1 : 0;
      return reg;
    }
  ],
  [
    // eqri: equal register/immediate
    "eqri",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = (reg[a]===b) ? 1 : 0;
      return reg;
    }
  ],
  [
    // eqrr: equal register/register
    "eqrr",
    function (a, b, c, regin) {
      let reg = regin.slice();
      reg[c] = (reg[a]===reg[b]) ? 1 : 0;
      return reg;
    }
  ]
]);

exports.execProgram = function(program, options) {
  options = options || {};
  let ipR = options.ipR || 0;
  let callback = options.callback || false;
  let opmap = options.opmap || exports.opMap;
  let reg = options.reg || [0, 0, 0, 0, 0, 0];
  // console.log(`ipR ${ipR} callback good opmap good reg ${reg}`);
  let ip = 0;
  let idx = 0;

  while (ip >= 0 && ip < program.length) {
    idx++;
    reg[ipR] = ip;
    let [opcode, a, b, c] = program[ip];
    if (!opmap.has(opcode)) {
      console.log(`WARNING: opcode (${typeof opcode}) ${opcode} not found in opmap`);
    }
    let newReg = opmap.get(opcode)(a, b, c, reg);
    if (callback) {
      let retval = callback(ipR, reg, idx, opcode, a, b, c);
      if (retval) return retval;
    }
    reg = newReg;
    ip = reg[ipR];
    ip++;
  }
  return [idx, reg];
}

exports.parseLines = function(lines) {
  let program = [];
  let ipR = 0;

  for (let line of lines) {
    let [addr, a, b, c] = line.split(' ');
    if (!addr) continue;
    if (addr === '#ip') {
      ipR = parseInt(a, 10);
    } else {
      program.push([addr, parseInt(a, 10), parseInt(b, 10), parseInt(c, 10)]);
    }
  }

  return [ ipR, program ];
}

exports.parseFile = function(filename) {
  let lines = fs.readFileSync(filename, 'utf8').split('\n');
  return exports.parseLines(fs.readFileSync(filename, 'utf8').split('\n'));
}
